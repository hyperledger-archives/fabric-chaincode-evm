/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

/*
Package types contains the types used to interact with the json-rpc
interface. It exists for users of fab3 types to use them without importing the
fabric protobuf definitions.
*/
package types

import (
	"encoding/json"
	"fmt"

	"github.com/pkg/errors"
)

/*
Input types used as arguments to ethservice methods.
*/

const (
	// HexEncodedAddressLegnth is 20 bytes, which is 40 chars when
	// hex-encoded
	HexEncodedAddressLegnth = 40
)

type EthArgs struct {
	To       string `json:"to"`
	From     string `json:"from"`
	Gas      string `json:"gas"`
	GasPrice string `json:"gasPrice"`
	Value    string `json:"value"`
	Data     string `json:"data"`
	Nonce    string `json:"nonce"`
}

type GetLogsArgs struct {
	FromBlock string        `json:"fromBlock,omitempty"`
	ToBlock   string        `json:"toBlock,omitempty"`
	Address   AddressFilter `json:"address,omitempty"`
}

type AddressFilter []string // 20 Byte Addresses

func (gla *GetLogsArgs) UnmarshalJSON(data []byte) error {
	type inputGetLogsArgs struct {
		FromBlock string      `json:"fromBlock"`
		ToBlock   string      `json:"toBlock"`
		Address   interface{} `json:"address"` // string or array of strings.
	}
	var input inputGetLogsArgs
	if err := json.Unmarshal(data, &input); err != nil {
		return err
	}
	gla.FromBlock = strip0x(input.FromBlock)
	gla.ToBlock = strip0x(input.ToBlock)

	if input.Address != nil {
		var af AddressFilter
		// DATA|Array, 20 Bytes - (optional) Contract address or a list of
		// addresses from which logs should originate.
		switch address := input.Address.(type) {
		case string:
			a, err := NewAddressFilter(address)
			if err != nil {
				return err
			}
			af = append(af, a...)
		case []interface{}:
			for i, address := range address {
				if singleAddress, ok := address.(string); ok {
					a, err := NewAddressFilter(singleAddress)
					if err != nil {
						return errors.Wrapf(err, "invalid address at position %d", i)
					}
					af = append(af, a...)
				}
			}
		default:
			return fmt.Errorf("badly formatted address field")
		}

		gla.Address = af
	}

	return nil
}

// NewAddressFilter takes a string and checks that is the correct length to
// represent a topic and strips the 0x
func NewAddressFilter(s string) (AddressFilter, error) {
	s = strip0x(s)
	if len(s) != HexEncodedAddressLegnth {
		return nil, fmt.Errorf("address in wrong format, need 40 chars prefixed with '0x', got %d chars for %q", len(s), s)
	}
	return AddressFilter{s}, nil
}

/*
Output types used as return values from ethservice methods.
*/

type TxReceipt struct {
	TransactionHash   string `json:"transactionHash"`
	TransactionIndex  string `json:"transactionIndex"`
	BlockHash         string `json:"blockHash"`
	BlockNumber       string `json:"blockNumber"`
	ContractAddress   string `json:"contractAddress"`
	GasUsed           int    `json:"gasUsed"`
	CumulativeGasUsed int    `json:"cumulativeGasUsed"`
	To                string `json:"to"`
	Logs              []Log  `json:"logs"`
	Status            string `json:"status"`
}

type Log struct {
	Address     string   `json:"address"`
	Topics      []string `json:"topics"`
	Data        string   `json:"data,omitempty"`
	BlockNumber string   `json:"blockNumber"`
	TxHash      string   `json:"transactionHash"`
	TxIndex     string   `json:"transactionIndex"`
	BlockHash   string   `json:"blockHash"`
	Index       string   `json:"logIndex"`
}

// Transaction represents an ethereum evm transaction.
//
// https://github.com/ethereum/wiki/wiki/JSON-RPC#returns-28
type Transaction struct { // object, or null when no transaction was found:
	BlockHash   string `json:"blockHash"`   // DATA, 32 Bytes - hash of the block where this transaction was in. null when its pending.
	BlockNumber string `json:"blockNumber"` // QUANTITY - block number where this transaction was in. null when its pending.
	To          string `json:"to"`          // DATA, 20 Bytes - address of the receiver. null when its a contract creation transaction.
	// From is generated by EVM Chaincode. Until account generation
	// stabilizes, we are not returning a value.
	//
	// From can be gotten from the Signature on the Transaction Envelope
	//
	// From string `json:"from"` // DATA, 20 Bytes - address of the sender.
	Input            string `json:"input"`            // DATA - the data send along with the transaction.
	TransactionIndex string `json:"transactionIndex"` // QUANTITY - integer of the transactions index position in the block. null when its pending.
	Hash             string `json:"hash"`             //: DATA, 32 Bytes - hash of the transaction.
}

// Block is an eth return struct
// defined https://github.com/ethereum/wiki/wiki/JSON-RPC#returns-26
type Block struct {
	Number     string `json:"number"`     // number: QUANTITY - the block number. null when its pending block.
	Hash       string `json:"hash"`       // hash: DATA, 32 Bytes - hash of the block. null when its pending block.
	ParentHash string `json:"parentHash"` // parentHash: DATA, 32 Bytes - hash of the parent block.
	// size: QUANTITY - integer the size of this block in bytes.
	// timestamp: QUANTITY - the unix timestamp for when the block was collated.
	Transactions []interface{} `json:"transactions"` // transactions: Array - Array of transaction objects, or 32 Bytes transaction hashes depending on the last given parameter.
}

func strip0x(s string) string {
	//Not checking for malformed addresses just stripping `0x` prefix where applicable
	if len(s) > 2 && s[0:2] == "0x" {
		return s[2:]
	}
	return s
}
